# Ranges

- [Запись лекции](https://youtu.be/l9RHsi9tFtE)

## Мотивационный пример
Хотим посортировать вектор:
```c++
vector<int> v;
sort(v.begin(), v.end());
```
Почему не сделали просто `sort(v)`? Чтобы можно было посортить промежуток. Ещё
иногда хотим посортировать в обратном порядке (или просто обойти вектор в
обратном порядке); т.е. так решили сделать для гибкости. Но очень часто мы не
пользуемся этой гибкостью. Нам хотелось бы иметь какой-нибудь шорткат типа
`sort(v)`. Просто добавить перегрузку можно но есть сложности (я не понял
какие, надо думать в сторону SFINAE).

Ренжи это как раз такой удобный набор утилит. Помимо того что писать приходится
меньше, мы также можем комбинировать алгоритмы друг с другом получая таким
образом легко читаемый код (пример про алгоритм парсинга *m3u* файла) и
эффективный код.

## Views
Помимо алгоритмов с ренджами в стандарт вошли *views*. Например мы можем
получить "reverse view" вектора, т.е. обертку которая ссылается на вектор и при
доступе к `i`-му элементу выдаёт `n-i-1`-й и т.п. Ещё можно создавать ленивые
последовательности и делать над ними преобразования:
```c++
total = accumulate(iota(1)
                  | transform([](int x) { return x * x; })
                  | take(10), 0)
```
В стандарте используется подмножество библиотеки range-v3.
Eric Niebler (автор пропозала) предлагает три способа обращения с ренжами:

### D-like ranges
Ренжи в D хранят набор ещё не обработанных элементов, т.е. они постоянно
сужаются. С такими ренжами сложно работать когда алгоритму нужно похранить
позицию, например `find`. В D эта проблема решается [кучей
функций](https://dlang.org/phobos/std_algorithm_searching.html#.findSplit).
Ещё такие ренжи плохи в алгоритмах типа `partial_sort` (там нужны три
итератора).

### Position-based ranges
position это что-то типа итератора но который ссылается не на сам элемент, а на
позицию в каком-то контейнере, который нужно явно передать. С такими ренжами
легко сделать проверку на границу диапазона. Ещё такие ренжи решают проблему
времени жизни - алгоритму нельзя передать протухший итератор. Минус такого
подхода в том что нам придется ввести кучу дополнительной машинерии для
interop-а обычных итераторов и positions.

### Iterator-based ranges
Ренж просто держит два итератора под капотом. Так были построены почти все
библиотеки для ренжей.


Пусть мы делаем какой-то view:
```c++
auto rng = views::reverse(v);
```
Должны ли мы полностью перекопировать себе вектор или только похранить
указатели? Копировать будет безопаснее, но вот сделать что-то типа
`transform(reverese(v))` будет очень дорого. В C++20 решили копировать один раз,
а дальше брать только указатели.

В стандартных ренжах определены два концепта:
[`range`](https://en.cppreference.com/w/cpp/ranges/range) и
[`view`](https://en.cppreference.com/w/cpp/ranges/view). У ренжа можно только
взять `begin` и `end` а view помимо этого ещё можно мувать за O(1). Чтобы тип
считался view, его нужно "пометить", специализировав переменную `enable_view`.
Ещё, стандарт запрещает инициализировать view через rvalue ренджи.

## Sentinel
У ренжов с begin и end одинакового типа есть проблема - итераторы в которых на
месте end() заглушка (например у `std::istream`, `std::regex_iterator`), из-за
этого приходится делать всякие проверки типа `is_end()` и т.п. Поэтому стандарт
разрешает делать begin и end разных типов, которые можно сравнивать между собой
(тогда проверка на заглушку остается на вызывающей стороне). Такие заглушки
называют sentinel-ами. А вообще range-based for мог работать с sentinel end-ом
уже в С++17. Кстати, для вещей типа `iota` есть
[`unreachable_sentinel`](https://en.cppreference.com/w/cpp/iterator/unreachable_sentinel_t).

## Алгоритмы на ренжах
На каждый алгоритм в STL сделали дополнительные перегрузки: одна для
двух итераторов с sentinel-ами, а вторая для ренжа. Для "трёхногих" алгоритмов
сделали по четыре доп. перегрузки.
Если захочется поиспользовать, то в std::ranges лежат улучшенные перегрузки
старых алгоритмов для ренжей, алгоритмы для view лежат std::ranges::views.

